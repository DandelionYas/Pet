## Outline

### Problem

As a software developer employed by an insurance company, you have created a distinct class for each client based on their respective categories. Recognizing that these clients share certain attributes, you abstracted these commonalities into a parent class known as the Client class. Initially, everything progressed smoothly, and you were satisfied with your development. However, your manager subsequently requested the implementation of an advertising messaging feature. This functionality would entail sending specific emails to clients based on their type, informing them of new insurance offers. For instance, a resident would receive a medical insurance advertisement, while a bank would be sent a theft insurance email.

At first glance, this task appeared straightforward. You intended to introduce a sendMail method within the Client class and override it in each subclass. This would allow you to iterate through your list of clients and invoke the sendMail method for each one. The solution seemed both simple and elegant, leveraging polymorphism effectively.

However, upon further examination, it became evident that this approach violated the principles of single responsibility and open-closed. The client classes, which initially functioned as Plain Old Java Objects, now incorporated actual functionalities that could potentially lead to future complications. These functionalities might involve interactions with third-party applications, such as Outlook. Moreover, any changes to the functionality or modifications to the advertisement or email behavior would necessitate revisiting and altering the code in each client class individually. Therefore, it is essential to extract these behaviors from the client classes to which they pertain.

### Solution

One way to do that is by following the Visitor Design Pattern.  The visitor pattern is a behavioral design pattern that lets you separate algorithms or behaviors from the objects on which they operate. Let's try to apply it to our clients' insurance for example. To do that, I went ahead and created an InsuranceMessagingVisitor class alongside its Visitor interface, then I moved all of our messaging behaviors to that particular interface and added their implementation to the corresponding Visitor class.  But what exactly would we call these methods, especially when dealing with several clients?  To pick the proper method, we need to check the class. Doesn't this sound like a nightmare?  You might also ask why don't we use we use a method. Go ahead and try to do that. Your code won't even compile and will ask you to cast the client object to one of its subclasses.  You see the exact class of a client object is unknown in advance and hence the overloading mechanism won't be able to determine the correct method to execute.  On the other hand, the visitor pattern addresses this by using a technique called: Double-Dispatch.  Since the objects know their own classes, the main idea here is to delegate choosing the proper method to the object itself instead of letting the client select a method. So, what each object will do is accept a visitor and tell it what visiting method should be executed and while dealing with a list of clients, all you have to do is invoke this acceptance method alongside a visitor.  

