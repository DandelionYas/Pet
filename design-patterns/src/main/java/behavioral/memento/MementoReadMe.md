## Scenario

### Problem

At some point, you decide to let users undo or control any operations carried out on the text. This feature has become so common over the years that, nowadays, people expect every app to have it. So, for the implementation, you choose to take snapshots of your text and save them as a history in some kind of storage, choose this example, we take a snapshot of our text area every time we added a new word to the text we are writing. Later, when a user decides to undo what he or she wrote, the app fetches the latest snapshot from history and uses it to restore what was previously written.  Let's think about the snapshots you are taking. How exactly would you produce one?  Suppose the object you are taking a snapshot of contains several fields and not just a simple text like this example, we'll probably need to go over all the fields of this object and copy their values into memory. However, for this to work, one of the requirements is that all the fields should be declared as public and, unfortunately, most objects hide their significant data inside private fields, ignore that problem for now and think about the actual snapshots, we took these snapshots will end up being several objects of one same class and this class would have almost no methods but lots of fields that mirror our initial object's state Now to allow other objects to write to and read data from a snapshot you'd probably need to expose these fields by making them public or using setters or anything else and by doing that you'd be exposing all the initial class fields private or not moreover other classes would become dependent on every little change made to the snapshot class The problems we just experienced are caused by broken encapsulation some objects try to do more than they are supposed to.  To collect the data required to perform some action, they invade the private space of other objects instead of letting these objects perform the actual action. So how do we solve this?

### Solution

Well, the Memento Pattern is a Behavioral Design Pattern that delegates creating the state snapshots to the actual owner of that state. Hence, instead of other objects trying to copy the initial object's state from outside the class, the original class itself can make the snapshot since it has full access to its own state.